# -*- coding: utf8 -*-

# Copyright (C) Christian Barral LÃ³pez - All Rights Reserved
# Unauthorized copyright of this file, via any medium is strictly prohibited
# Proprietary and confidential
# Written by Christian Barral <cbarrallopez@gmail.com>, May 2019

import csv
import logging

import PSCAD.lib.helpers.directory_helper as directory_helper

from datetime import datetime
from PSCAD.lib.helpers.colors import *
from scapy.layers.l2 import *
from scapy.layers.inet import *


class NetworkProfile:
    """ Contains the logic for packet processing when using the Sniffer, only used when a CSV file is selected
    by the user to detect anomalies based on the network scan results.

    It logs all the information gathered to a log file, with a custom format. Most of the methods defined are used
    to parse the input CSV or single packets, only the analyze_packet(pkt) method will be used publicly as a callback
    function for every packet captured by the sniffer.

        :param network_scan_file: Input CSV file
        :param output_directory: Directory where to write the log file.
        :type network_scan_file: str
        :type output_directory: str

    Apart from the __init__ function parameters, there are another attributes.
    Attributes:
        __packet_id: int. Used to mark every packet with a unique ID
    """

    def __init__(self, network_scan_file, output_directory):

        self.__network_information = self.__load_network_information(network_scan_file)
        self.__output_directory = directory_helper.process_directory(output_directory)
        self.__packet_id = 1
        # Config the logger to output the file to the selected output directory
        # with a custom name, and write 'time - message' for each line written
        # Set the logging level to DEBUG, the lowest one, so messages from DEBUG to CRITICAL show in file.
        logging.basicConfig(filename=self.__build_file_name(), filemode='w',
                            format='%(asctime)s - %(levelname)s %(message)s', datefmt='%d-%b-%y %H:%M:%S',
                            level=logging.DEBUG)

    @property
    def output_directory(self):
        return self.__output_directory

    @property
    def packet_id(self):
        return self.__packet_id

    def __build_file_name(self):
        """ Creates the standard logging output file name.

            :return: Built name
            :rtype: str
        """
        current_datetime = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

        return self.output_directory + '/' + 'net-info_' + current_datetime + '.log'

    def __load_network_information(self, network_scan_file):
        """ Creates a nested dictionary with all the information on the CSV file form a PSCAD scan.
        Only the IPs, ports, states and services are needed

            :param network_scan_file: CSV file used to build the network profile
            :type network_scan_file: str
            :return: Parsed ditionary with the network information
            :rtype: dict
        """

        parsed_dictionary = {}

        # If not CSV file, halt with error message
        if ".csv" not in network_scan_file:
            halt_fail("The sniff input file must be a CSV file generated by the scan.")

        with open(network_scan_file, 'r') as scan_file:

            # For each unique IP on the .csv file
            for single_ip in list(set([x[1] for x in csv.reader(scan_file)])):
                parsed_dictionary[single_ip] = {}

                # Get all port, state, service information for a current IP Address, transforming the port
                # format from port/protocol to int(port)
                for single_port, state, service in [(int(x[2].split('/')[0]), x[3], x[4]) for x in scan_file
                                                    if x[1] == single_ip]:
                    parsed_dictionary[single_ip][single_port] = {'state': state, 'service': service}

        return parsed_dictionary

    def analyze_packet(self, packet):
        """ Individually analyzes every single packet sniffed by the lib.sniffer.Sniffer class and looks for
        unusual behaviour, outputting everything to the .log file

        The information gathered is classified on different levels, depending on the matches that this method
        encounters:
            DEBUG and INFO: For simple packet logging, like source and destination IP/MAC Addresses and protocols
                used.
            WARNING: Host in network that is sending any type of packet from a registered and/or dynamic port(s)
                and ARP Packets trying to counter the application's ARP Poisoning.
            ERROR: Host is using a well-known port that is not specified on the network scanner or malformed packet.
            CRITICAL: An unknown host is sending packets through the network.

            :param packet: Packet to analyze.

        note::
            This method is built for using it as a callback function for packet sniffing in lib.sniffer.Sniffer
        """

        try:
            # Log packet structure
            logging.info('{%d} Packet structure: %s' % (self.packet_id, packet.summary()))
            # If there is Ethernet layer, get source and destination MAC. If no Ethernet layer is found, log an error.
            if Ether in packet:
                src_mac = packet.getlayer(Ether).src
                dst_mac = packet.getlayer(Ether).dst
            else:
                logging.error('{%d} Malformed packet with no Ethernet layer.' % self.packet_id)
                self.__packet_id += 1
                return

            # If there is no IP layer, it's a network scoped packet. Set src and dst IPs if they is IP layer
            if IP in packet:
                src_ip = packet.getlayer(IP).src
                dst_ip = packet.getlayer(IP).dst
            else:
                logging.info('{%d} Network scoped packet.' % self.packet_id)
                src_ip = None
                dst_ip = None

            # If it is an ARP Packet
            if ARP in packet:
                # If it is broadcast and source and destination are the same, it's Gratuitous
                if packet.getlayer(Ether).dst == 'ff:ff:ff:ff:ff:ff' and \
                        packet.getlayer(ARP).psrc == packet.getlayer(ARP).pdst:
                    logging.warning('{%d} Gratuitous ARP from %s.' %
                                    (self.packet_id, src_mac))

                # If it is a normal ARP
                else:
                    arp_packet = packet.getlayer(ARP)
                    # If ARP Request
                    if arp_packet.op == 1:
                        logging.debug('{%d} ARP Request for %s/%s asking for MAC address from %s' %
                                      (self.packet_id, arp_packet.psrc, arp_packet.hwsrc, arp_packet.pdst))
                    # If ARP Reply
                    else:
                        logging.debug('{%d} ARP Responses. %s sending %s MAC address to %s/%s' %
                                      (self.packet_id, arp_packet.psrc, arp_packet.hwsrc,
                                       arp_packet.pdst, arp_packet.hwdst))

            # Get source and destination ports depending on Transport layer protocols.
            if TCP in packet:
                src_port = packet.getlayer(TCP).sport
                dst_port = packet.getlayer(TCP).dport
                transport_protocol = 'TCP'

            elif UDP in packet:
                src_port = packet.getlayer(UDP).sport
                dst_port = packet.getlayer(UDP).dport
                transport_protocol = 'UDP'

            else:
                src_port = None
                dst_port = None
                transport_protocol = None

            # Log IP layer communication if there is an IP in the packet
            if src_ip is not None:
                # If the network host is the sender
                if src_ip in self.__network_information:
                    network_host = 'src'
                    logging.debug('{%d} IP Packet sent from %s/%s' %
                                  (self.packet_id, src_ip, src_mac))
                # If the network host is the receiver
                elif dst_ip in self.__network_information:
                    network_host = 'dst'
                    logging.debug('{%d} IP Packet recieved by %s/%s' %
                                  (self.packet_id, dst_ip, dst_mac))
                # If none of the other conditions, IP address is unknown
                else:
                    network_host = None
                    logging.critical('{%d} Unknown IP Address in communication %s/%s -> %s/%s captured' %
                                     (self.packet_id, src_ip, src_mac, dst_ip, dst_mac))

                # If there is a transport protocol and the host is known, analyze port
                if transport_protocol is not None and network_host is not None:
                    # Get port and ip values depending on if it's source or destination
                    if network_host == 'src':
                        port = src_port
                        ip = src_ip
                    else:
                        port = dst_port
                        ip = dst_ip
                    # If it is not a well known port
                    if not 0 < port <= 1024:
                        # If the port used is open or filtered
                        if port in self.__network_information[ip] and \
                                (self.__network_information[ip][port]['state'] in {'open', 'filtered'}):
                            logging.warning('{%d} %s using generic open/filtered port: %s with supposed service: %s' %
                                          (self.packet_id, ip, port, self.__network_information[ip][port]['service']))

                        # If the port is supposed to be closed
                        elif port in self.__network_information[ip] and \
                                'closed' in self.__network_information[ip][port]['state']:
                            logging.warning('{%d} %s using generic port: %s supposed as closed.' %
                                             (self.packet_id, ip, port))
                        # If unknown port
                        else:
                            logging.warning('{%d} %s using a generic non scanned port: %s' %
                                            (self.packet_id, ip, port))

                    # If it is not a well known port
                    else:
                        # If the port used is open or filtered
                        if port in self.__network_information[ip] and \
                                (self.__network_information[ip][port]['state'] in {'open', 'filtered'}):
                            logging.error('{%d} %s using open/filtered well-known port: %s with supposed service: %s' %
                                          (self.packet_id, ip, port, self.__network_information[ip][port]['service']))

                        # If the port is supposed to be closed
                        elif port in self.__network_information[ip] and \
                                'closed' in self.__network_information[ip][port]['state']:
                            logging.error('{%d} %s using well-known port: %s supposed as closed.' %
                                          (self.packet_id, ip, port))
                        # If unknown port
                        else:
                            logging.error('{%d} %s using a non scanned well-known port: %s' %
                                          (self.packet_id, ip, port))

            # Log Ethernet layer if no IP layer in the packet
            else:
                if 'ff:ff:ff:ff:ff:ff' in dst_mac:
                    logging.debug('{%d} Broadcast network packet sent from %s' %
                                  (self.packet_id, src_mac))
                else:
                    logging.debug('{%d} Network packet sent from %s to %s' %
                                  (self.packet_id, src_mac, dst_mac))

            self.__packet_id += 1

        # Log Exceptions
        except KeyboardInterrupt:
            logging.exception('User halted execution.')
        except Exception as e:
            logging.exception('Unexpected error: %s' % e)
